---
tags: [documentation, guide, formatting, automation]
provides: [formatting_guide, naming_implementation]
requires: [meta/guidelines/naming_conventions.md, docs/filename_transformations.md, meta/scripts/convert_to_dss.py]
---

# DSS Automation & Formatting Guide

> **Scope** â€“ This document compresses everything discussed about automated formatting within the DSS (Data SuperStructure) template so an LLM (e.g. Cursor agent) can reason about, extend, or refactor the system coherently.

---

## 1  Purpose

* Provide a **deterministic scaffold** (`convert_to_dss.py`) that reshapes arbitrary repos into DSS layout.
* Leverage **LLMâ€‘assisted docs generation** (`llm_tasks.py`) while preserving metadata & structure.
* Maintain a **tokenâ€‘lean, alwaysâ€‘current prompt context** for Cursor via `.cursor/rules/*.mdc`.
* Keep developer toil low with automated watchers (`sync_dss_mdc.py`), venv autoâ€‘activation, and CI hooks.

---

## 2  Canonical Folder Layout

```text
/src/      â€“ executable code
/data/     â€“ datasets / artifacts
/docs/     â€“ active docs & design notes
/docs/ðŸ”’archive/ â€“ historical material (ignored by tools)
/canvas/   â€“ Obsidian Canvas JSON (optional)
/meta/     â€“ scripts, prompts, config, tests
.cursor/rules/ â€“ .mdc files injected into every Cursor prompt
```

---

## 3  Key Automation Scripts

| Script                         | Responsibility                                                                                                                                         |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`meta/convert_to_dss.py`**   | *Deterministic layer* â€“ walk source tree, classify files, move/copy into DSS scaffold, inject YAML frontâ€‘matter stubs, create manifest. **This script should also be run on this template repository itself to ensure its own compliance with the DSS structure and conventions.** |
| **`meta/llm_tasks.py`**        | *Generative layer* â€“ batch LLM calls to create folder READMEs, module docs, INDEX.md, optional Canvas JSON. Reads prompt templates in `meta/prompts/`. |
| **`meta/sync_dss_mdc.py`**     | Watches `docs/DSS_OVERVIEW.md`; regenerates **`.cursor/rules/dss_overview.mdc`** only when the diff hash changes.                                      |
| *(optional)* `update_links.py` | Crossâ€‘link filenames â†’ markdown links; regen glossary.                                                                                                 |

---

## 4  LLM Context Files (Cursor)

* `.cursor/rules/assistant.mdc` â€“ core behavior & tone
* `.cursor/rules/dss_overview.mdc` â€“ tokenâ€‘efficient system summary (autoâ€‘synced)
* *(optional)* concise `dss_config.mdc` if classification rules are needed at promptâ€‘time

> **Exclusions:** anything in `docs/ðŸ”’archive/**`, binary assets, venv, manifest caches â€“ add to `.cursorignore`.

---

## 5  Metadata & Tagging

* All markdown & source files begin with YAML (or tripleâ€‘quoted) frontâ€‘matter:

```yaml
tags: [draft]
provides: []
requires: []
```

* Injection patterns & ignore globs live in `meta/dss_config.yml`.

---

## 6  Environment & Tooling

* **Virtualâ€‘env** at project root: `.venv/` (gitâ€‘ignored)
* **direnv** autoâ€‘activates venv via `.envrc`:

  ```bash
  layout python .venv  # or source .venv/Scripts/activate
  pgrep -f sync_dss_mdc.py >/dev/null || (python meta/sync_dss_mdc.py &)
  ```
* **API secrets**: `.env` (gitâ€‘ignored) â†’ `OPENAI_API_KEY=â€¦`
* **Preâ€‘commit**: run *Black* or other linters before commit.
* **requirements.txt** = loose deps; **requirements.lock** = frozen exact versions.

---

## 7  CI / GitHub Action (sketch)

```yaml
name: DSS CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: {python-version: '3.11'}
      - run: pip install -r meta/requirements.lock
      - run: python meta/convert_to_dss.py --source . --dest . --force
      - run: python meta/llm_tasks.py --mode docs --changed-only
        env: {OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}}
```

---

## 8  LLM Behaviour Rules (extract)

1. **Preserve frontâ€‘matter** â€“ don't drop `tags`, `provides`, `requires`.
2. **Respect structure** â€“ no folder reshuffles unless asked.
3. **Ignore `docs/ðŸ”’archive/`** â€“ never read or edit.
4. **Generate docs only on explicit request** â€“ via user prompt or `llm_tasks.py`.
5. **Explain uncertainty** â€“ if unsure, add a short note.

---

## 9  Filename Conventions & Implementation

### 9.1  LLM-Optimized Naming Principles

* **Semantic discoverability** â€“ Use descriptive names that LLMs can easily understand and retrieve.
* **Explicit over implicit** â€“ Include purpose/domain in filenames (e.g., `user_authentication.py` over `auth.py`).
* **Consistency in patterns** â€“ Use consistent naming patterns for similar file types.

### 9.2  Case Conventions by File Type

* **Python files**: `snake_case.py` (e.g., `data_processing_pipeline.py`)
* **Documentation**: `descriptive_name.md` or `topic-guide.md` (consistent within project)
* **Templates**: `purpose_template.md` (e.g., `index_template.md`)
* **Configuration**: `scope_config.yml` (e.g., `database_config.yml`)

### 9.3  Implementation Strategies

#### Automated Renaming

Add to `convert_to_dss.py` a filename transformation function:

```python
def transform_filename(path: Path, rules: Dict[str, any]) -> str:
    """Apply naming convention rules to a filename."""
    # Extract file stem and extension
    stem = path.stem
    suffix = path.suffix
    
    # Apply appropriate transformation based on file type
    if suffix == '.py':
        # Convert PascalCase or camelCase to snake_case
        transformed = re.sub(r'(?<!^)(?=[A-Z])', '_', stem).lower()
        
        # Add more descriptive prefix if generic (utils, helpers, etc.)
        generic_terms = rules.get('generic_terms', ['utils', 'helpers', 'common'])
        prefixes = rules.get('domain_prefixes', {})
        
        if stem.lower() in generic_terms and path.parent.name in prefixes:
            transformed = f"{prefixes[path.parent.name]}_{transformed}"
            
    elif suffix == '.md':
        # For docs, use either snake_case or kebab-case consistently
        doc_format = rules.get('doc_format', 'snake_case')
        if doc_format == 'kebab-case':
            transformed = re.sub(r'_', '-', stem.lower())
        else:
            transformed = stem.lower()
    
    # More rules for other file types...
    
    return transformed + suffix
```

#### Manual Implementation Approach

For existing repositories, follow these steps:

1. **Analyze current patterns**: Catalog existing files and their naming patterns.
2. **Create transformation map**: Document "before â†’ after" for key files.
3. **Update in groups**: Rename files by functional area, updating all references.
4. **Use git for safety**: Commit between steps, use rename detection (`git mv`).
5. **Update imports**: Scan for import statements and relative references.

### 9.4  Recommended Changes for This Repository

Current patterns in need of improvement:

| Current Pattern | Recommendation |
|-----------------|----------------|
| Generic file names (`utils.py`) | Add domain prefix (`string_utils.py`) |
| Abbreviated components (`api.py`, `db.py`) | Expand to full words (`api_endpoints.py`, `database.py`) |
| Mixed case conventions | Standardize on snake_case for Python, consistent format for docs |

### 9.5  Integration with DSS Tools

* Add naming conventions to `dss_config.yml` under a new `naming_rules` section.
* Extend `convert_to_dss.py` to handle filename transformations as a configurable option.
* Add a CLI flag `--normalize-names` to apply naming conventions during conversion.

---

> *DSS is a structured system for building structured systems â€“ evolve it intelligently, maintain metadata, and keep tokens lean.*
